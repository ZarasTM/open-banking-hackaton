'\n    enable:Banking SDK\n\n    Currently enable:Banking SDK consists of [authorization](#auth-api), [account information](#aisp-api) and [payment initiation](#pisp-api) APIs. The same calls and data structures are used for interacting with different banks. In order to use each of the APIs corresponding API instance needs to be created with bank specific settings.  enable:Banking SDK API is based on [STET PSD2 specification](https://www.stet.eu/en/psd2/).  This API intends to provide an interface for Third Party Providers (TPP) for accessing Account Servicing Payment Service Providers (ASPSP, i.e. banks).  TPP may act as Account Information Service Provider (AISP), Payment Initiation Service Providers (PISP) or both.  The Payment Service User (PSU) is the owner of the accounts held by the ASPSP and gives accreditations to the TPP in order to access his accounts information or initiates payment from these accounts.   # noqa: E501\n\n    API version: 0.3.0\n    Contact: hello@enablebanking.com\n    Generated by enable:Banking SDK generator using Swagger Codegen project\n'
_M='status_reason_information'
_L='transaction_status'
_K='remittance_information'
_J='regulatory_reporting_codes'
_I='ultimate_creditor'
_H='instructed_amount'
_G='execution_rule'
_F='end_date'
_E='requested_execution_date'
_D='payment_id'
_C='beneficiary'
_B='frequency'
_A=None
import pprint,re,six
from enablebanking.models.amount_type import AmountType
from enablebanking.models.beneficiary import Beneficiary
from enablebanking.models.end_date import EndDate
from enablebanking.models.execution_rule import ExecutionRule
from enablebanking.models.frequency_code import FrequencyCode
from enablebanking.models.party_identification import PartyIdentification
from enablebanking.models.payment_identification import PaymentIdentification
from enablebanking.models.regulatory_reporting_codes import RegulatoryReportingCodes
from enablebanking.models.requested_execution_date import RequestedExecutionDate
from enablebanking.models.status_reason_information import StatusReasonInformation
from enablebanking.models.transaction_individual_status_code import TransactionIndividualStatusCode
from enablebanking.models.unstructured_remittance_information import UnstructuredRemittanceInformation
class CreditTransferTransaction:
	'NOTE: This class is auto generated by the swagger code generator program.\n\n    Do not edit the class manually.\n    ';'\n    Attributes:\n      swagger_types (dict): The key is attribute name\n                            and the value is attribute type.\n      attribute_map (dict): The key is attribute name\n                            and the value is json key in definition.\n    ';swagger_types={_D:'PaymentIdentification',_E:'RequestedExecutionDate',_F:'EndDate',_G:'ExecutionRule',_B:'FrequencyCode',_H:'AmountType',_C:'Beneficiary',_I:'PartyIdentification',_J:'RegulatoryReportingCodes',_K:'UnstructuredRemittanceInformation',_L:'TransactionIndividualStatusCode',_M:'StatusReasonInformation'};attribute_map={_D:'paymentId',_E:'requestedExecutionDate',_F:'endDate',_G:'executionRule',_B:_B,_H:'instructedAmount',_C:_C,_I:'ultimateCreditor',_J:'regulatoryReportingCodes',_K:'remittanceInformation',_L:'transactionStatus',_M:'statusReasonInformation'}
	def __init__(A,payment_id=_A,requested_execution_date=_A,end_date=_A,execution_rule=_A,frequency=_A,instructed_amount=_A,beneficiary=_A,ultimate_creditor=_A,regulatory_reporting_codes=_A,remittance_information=_A,transaction_status=_A,status_reason_information=_A):
		'CreditTransferTransaction - a model defined in Swagger';K=status_reason_information;J=transaction_status;I=remittance_information;H=regulatory_reporting_codes;G=ultimate_creditor;F=frequency;E=execution_rule;D=end_date;C=requested_execution_date;B=payment_id;A._payment_id=_A;A._requested_execution_date=_A;A._end_date=_A;A._execution_rule=_A;A._frequency=_A;A._instructed_amount=_A;A._beneficiary=_A;A._ultimate_creditor=_A;A._regulatory_reporting_codes=_A;A._remittance_information=_A;A._transaction_status=_A;A._status_reason_information=_A;A.discriminator=_A
		if B is not _A:A.payment_id=B
		if C is not _A:A.requested_execution_date=C
		if D is not _A:A.end_date=D
		if E is not _A:A.execution_rule=E
		if F is not _A:A.frequency=F
		A.instructed_amount=instructed_amount;A.beneficiary=beneficiary
		if G is not _A:A.ultimate_creditor=G
		if H is not _A:A.regulatory_reporting_codes=H
		if I is not _A:A.remittance_information=I
		if J is not _A:A.transaction_status=J
		if K is not _A:A.status_reason_information=K
	@property
	def payment_id(self):'Gets the payment_id of this CreditTransferTransaction.  # noqa: E501\n\n\n        :return: The payment_id of this CreditTransferTransaction.  # noqa: E501\n        :rtype: PaymentIdentification\n        ';return self._payment_id
	@payment_id.setter
	def payment_id(self,payment_id):'Sets the payment_id of this CreditTransferTransaction.\n\n\n        :param payment_id: The payment_id of this CreditTransferTransaction.  # noqa: E501\n        :type: PaymentIdentification\n        ';self._payment_id=payment_id
	@property
	def requested_execution_date(self):'Gets the requested_execution_date of this CreditTransferTransaction.  # noqa: E501\n\n\n        :return: The requested_execution_date of this CreditTransferTransaction.  # noqa: E501\n        :rtype: RequestedExecutionDate\n        ';return self._requested_execution_date
	@requested_execution_date.setter
	def requested_execution_date(self,requested_execution_date):'Sets the requested_execution_date of this CreditTransferTransaction.\n\n\n        :param requested_execution_date: The requested_execution_date of this CreditTransferTransaction.  # noqa: E501\n        :type: RequestedExecutionDate\n        ';self._requested_execution_date=requested_execution_date
	@property
	def end_date(self):'Gets the end_date of this CreditTransferTransaction.  # noqa: E501\n\n\n        :return: The end_date of this CreditTransferTransaction.  # noqa: E501\n        :rtype: EndDate\n        ';return self._end_date
	@end_date.setter
	def end_date(self,end_date):'Sets the end_date of this CreditTransferTransaction.\n\n\n        :param end_date: The end_date of this CreditTransferTransaction.  # noqa: E501\n        :type: EndDate\n        ';self._end_date=end_date
	@property
	def execution_rule(self):'Gets the execution_rule of this CreditTransferTransaction.  # noqa: E501\n\n\n        :return: The execution_rule of this CreditTransferTransaction.  # noqa: E501\n        :rtype: ExecutionRule\n        ';return self._execution_rule
	@execution_rule.setter
	def execution_rule(self,execution_rule):'Sets the execution_rule of this CreditTransferTransaction.\n\n\n        :param execution_rule: The execution_rule of this CreditTransferTransaction.  # noqa: E501\n        :type: ExecutionRule\n        ';self._execution_rule=execution_rule
	@property
	def frequency(self):'Gets the frequency of this CreditTransferTransaction.  # noqa: E501\n\n\n        :return: The frequency of this CreditTransferTransaction.  # noqa: E501\n        :rtype: FrequencyCode\n        ';return self._frequency
	@frequency.setter
	def frequency(self,frequency):'Sets the frequency of this CreditTransferTransaction.\n\n\n        :param frequency: The frequency of this CreditTransferTransaction.  # noqa: E501\n        :type: FrequencyCode\n        ';self._frequency=frequency
	@property
	def instructed_amount(self):'Gets the instructed_amount of this CreditTransferTransaction.  # noqa: E501\n\n\n        :return: The instructed_amount of this CreditTransferTransaction.  # noqa: E501\n        :rtype: AmountType\n        ';return self._instructed_amount
	@instructed_amount.setter
	def instructed_amount(self,instructed_amount):
		'Sets the instructed_amount of this CreditTransferTransaction.\n\n\n        :param instructed_amount: The instructed_amount of this CreditTransferTransaction.  # noqa: E501\n        :type: AmountType\n        ';A=instructed_amount
		if A is _A:raise ValueError('Invalid value for `instructed_amount`, must not be `None`')
		self._instructed_amount=A
	@property
	def beneficiary(self):'Gets the beneficiary of this CreditTransferTransaction.  # noqa: E501\n\n\n        :return: The beneficiary of this CreditTransferTransaction.  # noqa: E501\n        :rtype: Beneficiary\n        ';return self._beneficiary
	@beneficiary.setter
	def beneficiary(self,beneficiary):
		'Sets the beneficiary of this CreditTransferTransaction.\n\n\n        :param beneficiary: The beneficiary of this CreditTransferTransaction.  # noqa: E501\n        :type: Beneficiary\n        ';A=beneficiary
		if A is _A:raise ValueError('Invalid value for `beneficiary`, must not be `None`')
		self._beneficiary=A
	@property
	def ultimate_creditor(self):'Gets the ultimate_creditor of this CreditTransferTransaction.  # noqa: E501\n\n\n        :return: The ultimate_creditor of this CreditTransferTransaction.  # noqa: E501\n        :rtype: PartyIdentification\n        ';return self._ultimate_creditor
	@ultimate_creditor.setter
	def ultimate_creditor(self,ultimate_creditor):'Sets the ultimate_creditor of this CreditTransferTransaction.\n\n\n        :param ultimate_creditor: The ultimate_creditor of this CreditTransferTransaction.  # noqa: E501\n        :type: PartyIdentification\n        ';self._ultimate_creditor=ultimate_creditor
	@property
	def regulatory_reporting_codes(self):'Gets the regulatory_reporting_codes of this CreditTransferTransaction.  # noqa: E501\n\n\n        :return: The regulatory_reporting_codes of this CreditTransferTransaction.  # noqa: E501\n        :rtype: RegulatoryReportingCodes\n        ';return self._regulatory_reporting_codes
	@regulatory_reporting_codes.setter
	def regulatory_reporting_codes(self,regulatory_reporting_codes):'Sets the regulatory_reporting_codes of this CreditTransferTransaction.\n\n\n        :param regulatory_reporting_codes: The regulatory_reporting_codes of this CreditTransferTransaction.  # noqa: E501\n        :type: RegulatoryReportingCodes\n        ';self._regulatory_reporting_codes=regulatory_reporting_codes
	@property
	def remittance_information(self):'Gets the remittance_information of this CreditTransferTransaction.  # noqa: E501\n\n\n        :return: The remittance_information of this CreditTransferTransaction.  # noqa: E501\n        :rtype: UnstructuredRemittanceInformation\n        ';return self._remittance_information
	@remittance_information.setter
	def remittance_information(self,remittance_information):'Sets the remittance_information of this CreditTransferTransaction.\n\n\n        :param remittance_information: The remittance_information of this CreditTransferTransaction.  # noqa: E501\n        :type: UnstructuredRemittanceInformation\n        ';self._remittance_information=remittance_information
	@property
	def transaction_status(self):'Gets the transaction_status of this CreditTransferTransaction.  # noqa: E501\n\n\n        :return: The transaction_status of this CreditTransferTransaction.  # noqa: E501\n        :rtype: TransactionIndividualStatusCode\n        ';return self._transaction_status
	@transaction_status.setter
	def transaction_status(self,transaction_status):'Sets the transaction_status of this CreditTransferTransaction.\n\n\n        :param transaction_status: The transaction_status of this CreditTransferTransaction.  # noqa: E501\n        :type: TransactionIndividualStatusCode\n        ';self._transaction_status=transaction_status
	@property
	def status_reason_information(self):'Gets the status_reason_information of this CreditTransferTransaction.  # noqa: E501\n\n\n        :return: The status_reason_information of this CreditTransferTransaction.  # noqa: E501\n        :rtype: StatusReasonInformation\n        ';return self._status_reason_information
	@status_reason_information.setter
	def status_reason_information(self,status_reason_information):'Sets the status_reason_information of this CreditTransferTransaction.\n\n\n        :param status_reason_information: The status_reason_information of this CreditTransferTransaction.  # noqa: E501\n        :type: StatusReasonInformation\n        ';self._status_reason_information=status_reason_information
	def to_dict(D):
		'Returns the model properties as a dict';E='to_dict';B={}
		for (C,G) in six.iteritems(D.swagger_types):
			A=getattr(D,C)
			if isinstance(A,list):B[C]=list(map(lambda x:x.to_dict()if hasattr(x,E)else x,A))
			elif hasattr(A,E):B[C]=A.to_dict()
			elif isinstance(A,dict):B[C]=dict(map(lambda item:(item[0],item[1].to_dict())if hasattr(item[1],E)else item,A.items()))
			else:B[C]=A
		if issubclass(CreditTransferTransaction,dict):
			for (F,A) in D.items():B[F]=A
		return B
	def to_str(A):'Returns the string representation of the model';return pprint.pformat(A.to_dict())
	def __repr__(A):'For `print` and `pprint`';return A.to_str()
	def __eq__(B,other):
		'Returns true if both objects are equal';A=other
		if not isinstance(A,CreditTransferTransaction):return False
		return B.__dict__==A.__dict__
	def __ne__(A,other):'Returns true if both objects are not equal';return not A==other