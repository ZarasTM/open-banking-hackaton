'\n    enable:Banking SDK\n\n    Currently enable:Banking SDK consists of [authorization](#auth-api), [account information](#aisp-api) and [payment initiation](#pisp-api) APIs. The same calls and data structures are used for interacting with different banks. In order to use each of the APIs corresponding API instance needs to be created with bank specific settings.  enable:Banking SDK API is based on [STET PSD2 specification](https://www.stet.eu/en/psd2/).  This API intends to provide an interface for Third Party Providers (TPP) for accessing Account Servicing Payment Service Providers (ASPSP, i.e. banks).  TPP may act as Account Information Service Provider (AISP), Payment Initiation Service Providers (PISP) or both.  The Payment Service User (PSU) is the owner of the accounts held by the ASPSP and gives accreditations to the TPP in order to access his accounts information or initiates payment from these accounts.   # noqa: E501\n\n    API version: 0.3.0\n    Contact: hello@enablebanking.com\n    Generated by enable:Banking SDK generator using Swagger Codegen project\n'
from __future__ import absolute_import
_O='Token'
_N='/token'
_M='application/x-www-form-urlencoded'
_L='GET'
_K='Content-Type'
_J='Accept'
_I='application/json'
_H='kwargs'
_G='_request_timeout'
_F='_preload_content'
_E=True
_D=None
_C='async_req'
_B='_return_http_data_only'
_A='redirect_uri'
import re,six
from enablebanking.api_client import ApiClient
class AuthApi:
	'NOTE: This class is auto generated by the swagger code generator program.\n\n    Do not edit the class manually.\n    Ref: https://github.com/swagger-api/swagger-codegen\n    '
	def __init__(self,api_client):self.api_client=api_client
	def get_auth(self,response_type,redirect_uri,scope,**kwargs):
		'Request Authorization Data  # noqa: E501\n\n        Get authorization data such as authorization URL   # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_auth(response_type, redirect_uri, scope, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str response_type: (required)\n        :param str redirect_uri: (required)\n        :param list[str] scope: (required)\n        :param str state:\n        :param Access access: Contains request for access to account information.  This parameter should be set to override defaults for the banks, which allow PSUs to give consent for account information sharing right after authentication. \n        :return: Auth\n                 If the method is called asynchronously,\n                 returns the request thread.\n        ';kwargs[_B]=_E
		if kwargs.get(_C):return self.get_auth_with_http_info(response_type,redirect_uri,scope,**kwargs)
		else:data=self.get_auth_with_http_info(response_type,redirect_uri,scope,**kwargs);return data
	def get_auth_with_http_info(self,response_type,redirect_uri,scope,**kwargs):
		'Request Authorization Data  # noqa: E501\n\n        Get authorization data such as authorization URL   # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_auth_with_http_info(response_type, redirect_uri, scope, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str response_type: (required)\n        :param str redirect_uri: (required)\n        :param list[str] scope: (required)\n        :param str state:\n        :param Access access: Contains request for access to account information.  This parameter should be set to override defaults for the banks, which allow PSUs to give consent for account information sharing right after authentication. \n        :return: Auth\n                 If the method is called asynchronously,\n                 returns the request thread.\n        ';D='access';C='state';B='response_type';A='scope';all_params=[B,_A,A,C,D];all_params.append(_C);all_params.append(_B);all_params.append(_F);all_params.append(_G);params=locals()
		for (key,val) in six.iteritems(params[_H]):
			if key not in all_params:raise TypeError("Got an unexpected keyword argument '%s' to method get_auth"%key)
			params[key]=val
		del params[_H]
		if B not in params or params[B]is _D:raise ValueError('Missing the required parameter `response_type` when calling `get_auth`')
		if _A not in params or params[_A]is _D:raise ValueError('Missing the required parameter `redirect_uri` when calling `get_auth`')
		if A not in params or params[A]is _D:raise ValueError('Missing the required parameter `scope` when calling `get_auth`')
		collection_formats={};path_params={};query_params=[]
		if B in params:query_params.append((B,params[B]))
		if _A in params:query_params.append((_A,params[_A]))
		if A in params:query_params.append((A,params[A]));collection_formats[A]='csv'
		if C in params:query_params.append((C,params[C]))
		header_params={};form_params=[];local_var_files={};body_params=_D
		if D in params:body_params=params[D]
		header_params[_J]=self.api_client.select_header_accept([_I]);header_params[_K]=self.api_client.select_header_content_type([_I]);auth_settings=[];return self.api_client.call_api('/auth',_L,path_params,query_params,header_params,body=body_params,post_params=form_params,files=local_var_files,response_type='Auth',auth_settings=auth_settings,async_req=params.get(_C),_return_http_data_only=params.get(_B),_preload_content=params.get(_F,_E),_request_timeout=params.get(_G),collection_formats=collection_formats)
	def get_current_token(self,**kwargs):
		'Get current token data  # noqa: E501\n\n        This method is used to retrieve current values of access, refresh and id tokens used for accessing AIS and PIS APIs.   # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_current_token(async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :return: Token\n                 If the method is called asynchronously,\n                 returns the request thread.\n        ';kwargs[_B]=_E
		if kwargs.get(_C):return self.get_current_token_with_http_info(**kwargs)
		else:data=self.get_current_token_with_http_info(**kwargs);return data
	def get_current_token_with_http_info(self,**kwargs):
		'Get current token data  # noqa: E501\n\n        This method is used to retrieve current values of access, refresh and id tokens used for accessing AIS and PIS APIs.   # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.get_current_token_with_http_info(async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :return: Token\n                 If the method is called asynchronously,\n                 returns the request thread.\n        ';all_params=[];all_params.append(_C);all_params.append(_B);all_params.append(_F);all_params.append(_G);params=locals()
		for (key,val) in six.iteritems(params[_H]):
			if key not in all_params:raise TypeError("Got an unexpected keyword argument '%s' to method get_current_token"%key)
			params[key]=val
		del params[_H];collection_formats={};path_params={};query_params=[];header_params={};form_params=[];local_var_files={};body_params=_D;header_params[_J]=self.api_client.select_header_accept([_I]);header_params[_K]=self.api_client.select_header_content_type([_M]);auth_settings=[];return self.api_client.call_api(_N,_L,path_params,query_params,header_params,body=body_params,post_params=form_params,files=local_var_files,response_type=_O,auth_settings=auth_settings,async_req=params.get(_C),_return_http_data_only=params.get(_B),_preload_content=params.get(_F,_E),_request_timeout=params.get(_G),collection_formats=collection_formats)
	def make_token(self,grant_type,code,**kwargs):
		'Request Access Token  # noqa: E501\n\n        Requests new access token for retrieving data on behalf of the authenticated user.   # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.make_token(grant_type, code, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str grant_type: Value should be set to `authorization_code` or `refresh_token` depending on what passed to `code` parameter.  (required)\n        :param str code: Value of either the code received in the query string when redirected from authorization page or the refresh token used for renewing access token.  (required)\n        :param str redirect_uri: Redirect URI supplied to [`getAuth`](#getauth) function for retreival of the authorization URL. This parameter is only required for some connectors, but it is a good practice to pass it in order to unify usage for between different connectors. \n        :return: Token\n                 If the method is called asynchronously,\n                 returns the request thread.\n        ';kwargs[_B]=_E
		if kwargs.get(_C):return self.make_token_with_http_info(grant_type,code,**kwargs)
		else:data=self.make_token_with_http_info(grant_type,code,**kwargs);return data
	def make_token_with_http_info(self,grant_type,code,**kwargs):
		'Request Access Token  # noqa: E501\n\n        Requests new access token for retrieving data on behalf of the authenticated user.   # noqa: E501\n        This method makes a synchronous HTTP request by default. To make an\n        asynchronous HTTP request, please pass async_req=True\n        >>> thread = api.make_token_with_http_info(grant_type, code, async_req=True)\n        >>> result = thread.get()\n\n        :param async_req bool\n        :param str grant_type: Value should be set to `authorization_code` or `refresh_token` depending on what passed to `code` parameter.  (required)\n        :param str code: Value of either the code received in the query string when redirected from authorization page or the refresh token used for renewing access token.  (required)\n        :param str redirect_uri: Redirect URI supplied to [`getAuth`](#getauth) function for retreival of the authorization URL. This parameter is only required for some connectors, but it is a good practice to pass it in order to unify usage for between different connectors. \n        :return: Token\n                 If the method is called asynchronously,\n                 returns the request thread.\n        ';B='code';A='grant_type';all_params=[A,B,_A];all_params.append(_C);all_params.append(_B);all_params.append(_F);all_params.append(_G);params=locals()
		for (key,val) in six.iteritems(params[_H]):
			if key not in all_params:raise TypeError("Got an unexpected keyword argument '%s' to method make_token"%key)
			params[key]=val
		del params[_H]
		if A not in params or params[A]is _D:raise ValueError('Missing the required parameter `grant_type` when calling `make_token`')
		if B not in params or params[B]is _D:raise ValueError('Missing the required parameter `code` when calling `make_token`')
		collection_formats={};path_params={};query_params=[];header_params={};form_params=[];local_var_files={}
		if A in params:form_params.append((A,params[A]))
		if B in params:form_params.append((B,params[B]))
		if _A in params:form_params.append((_A,params[_A]))
		body_params=_D;header_params[_J]=self.api_client.select_header_accept([_I]);header_params[_K]=self.api_client.select_header_content_type([_M]);auth_settings=[];return self.api_client.call_api(_N,'POST',path_params,query_params,header_params,body=body_params,post_params=form_params,files=local_var_files,response_type=_O,auth_settings=auth_settings,async_req=params.get(_C),_return_http_data_only=params.get(_B),_preload_content=params.get(_F,_E),_request_timeout=params.get(_G),collection_formats=collection_formats)